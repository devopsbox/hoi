// Copyright 2016 Atelier Disko. All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
package project

import (
	"errors"
	"fmt"
	"hash/adler32"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/hashicorp/hcl"
)

const CERT_ACME string = "!acme"
const CERT_OWNCA string = "!own-ca"
const CERT_SELFSIGNED string = "!self-signed"
const DERIVED string = "!derived"
const AUTOGEN string = "!autogenerated"
const WWW_KEEP string = "keep"
const WWW_DROP string = "drop"
const WWW_ADD string = "add"

type Config struct {
	ProjectDirective `hcl:",squash"`
	Domain           map[string]DomainDirective
	Worker           map[string]WorkerDirective
	Cron             map[string]CronDirective
	Seal             SealDirective
	Backup           BackupDirective
	Log              LogDirective
	Database         map[string]DatabaseDirective
}

type ProjectDirective struct {
	Name                 string
	Path                 string
	Context              string
	UsePHP               bool
	UsePHPLegacyRewrites bool
	PHPVersion           string
	UseLargeUploads      bool
	UseMediaVersions     bool
	UseMediaTransfers    bool
	UseFiles             bool
	UseAssets            bool
	// Whether to use classic img/js/css dirs.
	UseClassicAssets bool
	// host all subpaths with a prefixed
	// undersore i.e. /media under /_media
	UseNoConflict bool
}

func (c *ProjectDirective) Id() string {
	if c.Path == "" {
		log.Fatal(errors.New("no path to generate id"))
	}
	return fmt.Sprintf("%s_%s_%x", c.Name, c.Context, adler32.Checksum([]byte(c.Path)))
}

func (c *ProjectDirective) PrettyName() string {
	if c.Name != "" {
		if c.Context != "" {
			return fmt.Sprintf("%s@%s", c.Name, c.Context)
		}
		return fmt.Sprintf("%s@?", c.Name)
	}
	return fmt.Sprintf("? in %s", filepath.Base(c.Path))
}

func (c *ProjectDirective) Augment() error {
	log.Printf("discovering project configuration in %s", prettyPath(c.Path))

	if _, err := os.Stat(c.Path + "/app/webroot/index.php"); err == nil {
		log.Print("- using PHP")
		c.UsePHP = true

		legacy, err := fileContainsString(c.Path+"/app/webroot/index.php", "cake")
		if err != nil {
			return err
		}
		if legacy {
			log.Print("- using legacy rewrites")
			c.UsePHPLegacyRewrites = true
		}
		log.Print("- using large uploads")
		c.UseLargeUploads = true
	}

	if _, err := os.Stat(c.Path + "/assets"); err == nil {
		c.UseAssets = true
	}
	if _, err := os.Stat(c.Path + "/media/versions"); err == nil {
		c.UseMediaVersions = true
	}
	if _, err := os.Stat(c.Path + "/media/transfers"); err == nil {
		c.UseMediaTransfers = true
	}
	if _, err := os.Stat(c.Path + "/files"); err == nil {
		c.UseFiles = true
	}
	if _, err := os.Stat(c.Path + "/app/webroot/css"); err == nil {
		c.UseAssets = true
		c.UseClassicAssets = true
	}
	return nil
}

func fileContainsString(file string, search string) (bool, error) {
	b, err := ioutil.ReadFile(file)
	if err != nil {
		return false, err
	}
	s := string(b)
	return strings.Contains(s, search), nil
}

func decodeInto(cfg *Config, s string) (*Config, error) {
	err := hcl.Decode(cfg, s)

	if err != nil {
		return cfg, err
	}
	for k, _ := range cfg.Domain {
		e := cfg.Domain[k]
		e.FQDN = k

		if e.SSL.Certificate != "" {
			if filepath.IsAbs(e.SSL.Certificate) {
				return cfg, fmt.Errorf("domain %s has absolute cert path", e.FQDN)
			}
			e.SSL.Certificate = filepath.Join(cfg.Path, e.SSL.Certificate)

			if e.SSL.CertificateKey == "" {
				return cfg, fmt.Errorf("domain %s has cert but no cert key", e.FQDN)
			}
			if filepath.IsAbs(e.SSL.CertificateKey) {
				return cfg, fmt.Errorf("domain %s has absolute cert key path", e.FQDN)
			}
			e.SSL.CertificateKey = filepath.Join(cfg.Path, e.SSL.CertificateKey)
		}
		cfg.Domain[k] = e
	}
	for k, _ := range cfg.Cron {
		e := cfg.Cron[k]
		e.Name = k

		if !filepath.IsAbs(e.Command) {
			e.Command = filepath.Join(cfg.Path, e.Command)
		}
		cfg.Cron[k] = e
	}
	for k, _ := range cfg.Worker {
		e := cfg.Worker[k]
		e.Name = k

		if !filepath.IsAbs(e.Command) {
			e.Command = filepath.Join(cfg.Path, e.Command)
		}
		cfg.Worker[k] = e
	}
	return cfg, nil
}

type DomainDirective struct {
	FQDN      string
	WWW       string // keep, drop, add
	SSL       SSLDirective
	Auth      AuthDirective
	Aliases   []string
	Redirects []string
}

// SSL is considered enabled, once a value for Certificate is given.
type SSLDirective struct {
	// Paths to certificate and certificate key. Paths are relative to
	// project root i.e. config/ssl/example.org.crt.
	//
	// TODO Allows special strings "own-ca", "self-signed" and "acme".
	// own-ca: will generate a self-signed corp cert on the fly
	// self-signed: will generate a self-signed cert on the fly
	// acme: will use letsencrypt to get a valid cert and renew it automatically
	Certificate    string
	CertificateKey string
}

// Auth is considered enabled, once a value for User is given. Empty
// passwords are not allowed.
type AuthDirective struct {
	// TODO Allows special value "derived" where the User is taken
	// from the project name. acme_stage -> acme, acme -> acme, acme_shop -> acme
	User string
	// TODO Allows special value "autogenerate" where an unsafe password
	// is generated and mailed to the administrator.
	Password string
}
type DatabaseDirective struct {
	Database string
	User     string
	Password string
}
type BackupDirective struct {
	Onsite  bool
	Offsite bool
}
type LogDirective struct {
	Rotate bool
}
type SealDirective struct {
	Ignore []string
}
type WorkerDirective struct {
	// Descriptive name, to identify the worker.
	Name string
	// Can be relative to project root or absolute.
	Command string
}
type CronDirective struct {
	// Descriptive name, to identify the cron.
	Name string
	// See systemd.time for valid syntaxes:
	// https://www.freedesktop.org/software/systemd/man/systemd.time.html
	Schedule string
	// Can be relative to project root or absolute.
	Command string
}

func New() (*Config, error) {
	cfg := &Config{}

	return cfg, nil
}

func NewFromFile(f string) (*Config, error) {
	cfg := &Config{}

	b, err := ioutil.ReadFile(f)
	if err != nil {
		return cfg, err
	}

	cfg, err = decodeInto(cfg, string(b))
	if err != nil {
		return cfg, fmt.Errorf("Failed to parse config file %s: %s", f, err)
	}
	cfg.Path = filepath.Dir(f)
	return cfg, nil
}

func NewFromString(s string) (*Config, error) {
	cfg := &Config{}
	return decodeInto(cfg, s)
}

func prettyPath(path string) string {
	cwd, err := os.Getwd()
	if err != nil {
		return path
	}
	return strings.Replace(path, cwd, ".", 1)
}
